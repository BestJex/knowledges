
例如：uint32_t i=58585858;

i的二进制表示是：`0000 0011 0111 1101 1111 0011 0000 0010`

于是，i的二进制表示包含15个1。


# 一、位移法

## 思路：
既然输入n是uint32，每次取n的最低位，判断是不是1，位移32次，循环判断即可。

## 伪代码：
```java
do{

    if ((n&1)==1){

       result++;

    }

    n>>= 1;

    i++;

} while(i<32);
```

## 分析：
不管n的二进制表示里包含多少个1，都需要循环计算32次，比较耗时。有没有可能，每次消除掉一个1，这样来降低计算次数呢？

# 二、求与法

观察一下n和n-1这两个数相与的二进制表示：
```shell
          x = 1011 0000        
         x-1= 1010 1111
x & (x-1) = 1010 0000
```

于是，`n&(n-1)`这个操作，可以起到“消除最后一个1”的功效。 


**思路**：逐步通过n&(n-1)，来消除n末尾的1，消除了多少次，就有多少个1。

**伪代码**：
```java
while(n){

   result++;

   n&=(n-1);

}
```
**分析**：这个方法，n的二进制表示有多少个1，就会计算多少次。总的来说，n的长度是32bit，如果n的值选取完全随机，平均期望由16个1构成，平均下来16次，节省一半的计算量。

**另**：该方法也可以用于快速判断一个正整数是不是2的x次幂？

`return !(n&(n-1));`

如果n是2的x次幂，二进制表示只有一个1。

# 三、查表法

## 思路
空间换时间，是算法优化中最常见的手段，如果有相对充裕的内存，可以有更快的算法。

一个uint32的正整数n，一旦n的值确定，n的二进制表示中包含多少个1也就确定了，理论上无需重新计算：
* 1的二进制表示中包含1个1
* 2的二进制表示中包含1个1
* 3的二进制表示中包含2个1

查表法的好处是，时间复杂度为O(1)，潜在的问题是，需要很大的内存。

## 内存分析

假如被分析的整数是uint32，打表数组需要记录2^32个正整数的结果。

n的二进制表示最多包含32个1，存储结果的计数，使用5个bit即可。

故，共需要内存2^32 * 5bit = 2.5GB。

# 四、二次查表法


## 思路：
1. 把uint32的正整数n，分解为低16位正整数n1，和高16正整数n2；

2. n1查一次表，其二进制表示包含a个1；

3. n2查一次表，其二进制表示包含b个1；

4. 则，n的二进制表示包含a+b个1；

##  伪代码：
 ```java
uint16 n1 = n & 0xFFFF;

uint16 n2 = (n>>16) & 0xFFFF;

return  result[n1]+result[n2];
```
 
 ## 内存分析
 问题来了：增加了一倍的计算量（1次查表变2次查表），内存空间是不是对应减少一半呢？
 
 被分析的整数变成uint16，打表数组需要记录2^16个正整数的结果。
 
 n1和n2的二进制表示最多包含16个1，存储结果的计数，使用4个bit即可。
 
 故，共需要内存2^16 * 4bit = 32KB。
 
 
计算量多了1倍，内存占用量却由2.5G降到了32K（1万多倍）